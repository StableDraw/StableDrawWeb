syntax = "proto3";
import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";
option csharp_namespace = "GrpcGreeterClient";
package greet;

service StableDrawGRPC
{
  /*Генерация описания к изображению
  Принимает: byte входного изображения и параметры
  Возвращает: строку описания изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "ckpt": "caption_huge_best.pt", #используемые чекпоинты (caption_huge_best.pt или caption_base_best.pt)
    "eval_cider": True,             #оценка с помощью баллов CIDEr
    "eval_bleu": False,             #оценка с помощью баллов BLEU
    "eval_args": "{}",              #аргументы генерации для оценки BLUE или CIDEr, например, "{"beam": 4, "lenpen": 0,6}", в виде строки JSON
    "eval_print_samples": False,    #печатать поколения образцов во время валидации
    "scst": False,                  #Обучение самокритичной последовательности
    "scst_args": "{}",              #аргументы генерации для обучения самокритичной последовательности в виде строки JSON
    "beam": 5,                      #балансировка
    "max_len_a": 0,                 #максимальная длина буфера a
    "max_len_b": 200,               #максимальная длина буфера b
    "min_len": 1,                   #минимальная длина буфера
    "unnormalized": False,          #ненормализовывать
    "lenpen": 1,
    "unkpen": 0,
    "temperature": 1.0,             #температура
    "match_source_len": False,      #сопоставлять с исходной длиной
    "no_repeat_ngram_size": 3,      #не повторять N-граммы размера
    "sampling_topk": 3,             #из скольки тоненов отбирать лучший (0 - не использовать сэмплирование)
    "seed": 7                       #инициализирующее значение для генерации
  }*/
  rpc GenCaption (FromImageRequest) returns (TextReply);
  /*Генерация изображения по описанию
  Принимает: строку описания и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "steps": 50,            #количество шагов выборки
    "samler": "ddim",       #обработчик (доступно "plms", "dpm" и "ddim")
    "ddim_eta": 0.0,        #ddim η (η = 0.0 соответствует детерминированной выборке, работает только на обработчике "ddim")
    "f": 8,                 #коэффициент понижающей дискретизации, чаще всего 8 или 16
    "scale": 9.0,           #безусловная навигационная величина: eps = eps(x, empty) + scale * (eps(x, cond) - eps(x, empty))
    "ckpt": 0,              #выбор контрольной точки модели (0 или 1 для размерностей 512 или 768 соответственно)
    "seed": 42,             #сид (для воспроизводимой генерации изображений)
    "precision": "autocast" #оценивать с этой точностью ("full" или "autocast")
  }*/
  rpc StableDiffusionTextToImage (FromTextRequest) returns (ImageReply);
  /*Генерация изображения по описанияю и изображению
  Принимает: byte входного изображения и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    'ddim_steps': 50,             #количество шагов выборки ddim
    'ddim_eta': 0.0,              #ddim η (η = 0.0 соответствует детерминированной выборке)
    'f': 8,                       #коэффициент понижающей дискретизации, чаще всего 8 или 16
    'scale': 9.0,                 #безусловная навигационная величина: eps = eps(x, empty) + scale * (eps(x, cond) - eps(x, empty))
    'strength': 0.7,              #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
    'ckpt': 0,                    #выбор весов модели (от 0 до 10)
    'seed': 42,                   #сид (для воспроизводимой генерации изображений)
    'precision': "autocast",      #оценивать с этой точностью ("full" или "autocast")
    "max_dim": pow(512, 2)        # я не могу генерировать на своей видюхе картинки больше 512 на 512
  }*/
  rpc StableDiffusionImageToImage (FromImageandTextRequest) returns (ImageReply);
  /*Генерация изображения по описанияю и изображению с применением дополнительного слоя глубины
  Принимает: byte входного изображения, строку описания и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "ddim_steps": 50,           #Шаги DDIM, от 0 до 50
    "ddim_eta": 0.0,            #ddim η (η = 0.0 соответствует детерминированной выборке)
    "scale": 9.0,               #от 0.1 до 30.0
    "strength": 0.9,            #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
    "ckpt": 0,                  #выбор весов модели (0)
    "seed": 42,                 #от 0 до 1000000
    "model_type": "dpt_hybrid", #тип модели
    "verbose": True,
    "max_dim": pow(512, 2)      # я не могу генерировать на своей видюхе картинки больше 512 на 512
  }*/
  rpc StableDiffusionDepthToImage (FromImageandTextRequest) returns (ImageReply);
  /*Генерация изображения с изменённым фрагментам по изображению, маске и описанию
  Принимает: byte входного изображения, byte изображения маски, строку описания и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "ddim_steps": 50,           #Шаги DDIM, от 0 до 50
    "ddim_eta": 0.0,            #ddim η (от 0.0 до 1.0, η = 0.0 соответствует детерминированной выборке)
    "scale": 10.0,              #от 0.1 до 30.0
    "strength": 0.9,            #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
    "ckpt": 0,                  #выбор весов модели (0)
    "seed": 42,                 #от 0 до 1000000
    "verbose": False,
    "max_dim": pow(512, 2)      #я не могу генерировать на своей видюхе картинки больше 512 на 512
  }*/
  rpc StableDiffusionInpainting (FromImgandMaskandTextRequest) returns (ImageReply);
  /*Четырёхкратное увеличение разрешения исходного изображения (апскейл) по изображению и описанию
  Принимает: byte входного изображения, строку описания и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "ddim_steps": 50,           #Шаги DDIM, от 2 до 250
    "ddim_eta": 0.0,            #ddim η (от 0.0 до 1.0, η = 0.0 соответствует детерминированной выборке)
    "scale": 9.0,               #от 0.1 до 30.0
    "ckpt": 0,                  #выбор весов модели (0)
    "seed": 0,                  #от 0 до 1000000
    "outscale": 4,              #Величина того, во сколько раз увеличть разшрешение изображения
    "noise_augmentation": 20,   #от 0 до 350
    "verbose": False,
    "max_dim": pow(256, 2)      # я не могу генерировать на своей видюхе картинки больше 256 на 256
  }*/
  rpc StableDiffusionUpscaler (FromImageandTextRequest) returns (ImageReply);
  /*Многократное (2 предпочтительно) увеличение разрешения исходного изображения (апскейл) по изображению и описанию
  Принимает: byte входного изображения, строку описания и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "ddim_steps": 20,           #Шаги DDIM, от 2 до 250
    "scale": 0.0,               #от 0.1 до 30.0
    "ckpt": 0,                  #выбор весов модели (0)
    "seed": 0,                  #от 0 до 1000000
    "outscale": 2,              #Величина того, во сколько раз увеличть разшрешение изображения
    "noise_augmentation": 0.0,  #от 0.0 до 1.0
    "negative_prompt": None,    #отрицательное описание (если без него, то None)
    "verbose": False,
    "max_dim": pow(512, 2)      # я не могу генерировать на своей видюхе картинки больше 256 на 256 для x4 и 512 на 512 для x2
  }*/
  rpc StableDiffusionUpscalerXX (FromImageandTextRequest) returns (ImageReply);
  /*Увеличение разрешения исходного изображения (апскейл) по изображению
  Принимает: byte входного изображения и параметры
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
    "model": 0,                         #Номер модели для обработки (0-5)
    "denoise_strength": 0.5,            #Сила удаления шума. 0 для слабого удаления шума (шум сохраняется), 1 для сильного удаления шума. Используется только для модели 5 (realesr-general-x4v3 model)
    "outscale": 4,                      #Величина того, во сколько раз увеличть разшрешение изображения (модель 3 x2, остальные x4)
    "tile": 0,                          #Размер плитки, 0 для отсутствия плитки во время тестирования
    "tile_pad": 10,                     #Заполнение плитки
    "pre_pad": 0,                       #Предварительный размер заполнения на каждой границе
    "face_enhance": False,              #Использовать GFPGAN улучшения лиц
    "fp32": True,                       #Использовать точность fp32 во время вывода. По умолчанию fp16 (половинная точность)
    "alpha_upsampler": "realesrgan",    #Апсемплер для альфа-каналов. Варианты: realesrgan | bicubic
    "gpu-id": None                      #Устройство gpu для использования (по умолчанию = None) может быть 0, 1, 2 для обработки на нескольких GPU
  }*/
  rpc Upscale (FromImageRequest) returns (ImageReply);
  /*Удаление фона изображения
  Принимает: byte входного изображения
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
      "model": "DIS", #Доступно "U2NET" или "DIS"
      "RescaleT": 320, #Только для модели U2NET
      #Только для модели "DIM":
      "ckpt": 0,                  # Выбор впретренированных весов модели (0 или 1)
      "interm_sup": False,        # Указать, активировать ли контроль промежуточных функций
      "model_digit": "full",      # Выберите точность с плавающей запятой (устанавливает "half" или "full" точность числа с плавающей запятой)
      "seed": 0,                  # Инициализирующее значение
      "cache_size": [1024, 1024], # Кешированное входное пространственное разрешение, можно настроить на другой размер
      "input_size": [1024, 1024], # Входной пространственный размер модели, обычно используют одно и то же значение params["cache_size"], что означает, что мы больше не изменяем размер изображений
      "crop_size": [1024, 1024]   # Размер случайно обрезки из ввода, обычно он меньше, чем params["cache_size"], например, [920, 920] для увеличения данных
  }*/
  rpc DeleteBackground (FromImageRequest) returns (ImageReply);
  /*Получение класса изображения
  Принимает: byte входного изображения
  Возвращает: int класса, где:
    0 - фото с лицом,
    1 - фото без лица,
    2 - профессиональный рисунок,
    3 - непрофессиональный рисунок,
    4 - профессиональный лайн,
    5 - быстрый лайн*/
  rpc GetImageClass (FromImgOnlyRequest) returns (IntReply);
  /*Окрашивание чёрно-белого изображения или лайна
  Принимает: byte входного изображения
  Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
  Структура словаря параметров и параметры по-умолчанию:
  params = {
      "ckpt": 0,                         #Выбор модели (от 0 до 3)
      "steps": 1,                        #Количество шагов обработки (минимум 1)
      "compare": False,                  #Сравнивать с оригиналом
      "artistic": True,                  #Дополнительная модель для обработки
      "render_factor": 12,               #Фактор обработки (от 7 до 45) (лучше 12)
      "post_process": True,              #Постобработка
      "clr_saturation_factor": 5,        #Коэффициент увеличения цветовой насыщенности (1 - не добавлять насыщенность)
      "line_color_limit": 50,            #минимальная яркость пикселя, при которой цветовая насыщенность увеличиваться не будет (меньше для цифровых рисунков, больше для рисунков карандашом. 1 если лайн абсолютно чёрный)
      "clr_saturate_every_step": True    #Повышать цветовую насыщенность после каждого шага (играет роль только если количество шагов обработки больше 1)
  }*/
  rpc ImageColorizer (FromImageRequest) returns (ImageReply);
}

message FromImageRequest
{
  bytes init_img_binary_data = 1;
  map<string, google.protobuf.Value> params = 2;
}

message FromTextRequest
{
  string caption = 1;
  map<string, google.protobuf.Value> params = 2;
}

message FromImageandTextRequest
{
  bytes init_img_binary_data = 1;
  string caption = 2;
  map<string, google.protobuf.Value> params = 3;
}

message FromImgandMaskandTextRequest
{
  bytes init_img_binary_data = 1;
  bytes mask = 2;
  string caption = 3;
  map<string, google.protobuf.Value> params = 4;
}

message FromImgOnlyRequest
{
  bytes init_img_binary_data = 1;
}

message TestRequest
{
  string str = 1;
}

message TextReply
{
  string caption = 1;
}

message ImageReply
{
  int64 w = 1;
  int64 h = 2;
  bytes binary_data = 3;
}

message IntReply
{
  int64 c = 1;
}