# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import stable_draw_grpc_pb2 as stable__draw__grpc__pb2


class StableDrawGRPCStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GenCaption = channel.unary_unary(
                '/greet.StableDrawGRPC/GenCaption',
                request_serializer=stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.TextReply.FromString,
                )
        self.StableDiffusionTextToImage = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionTextToImage',
                request_serializer=stable__draw__grpc__pb2.FromTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.StableDiffusionImageToImage = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionImageToImage',
                request_serializer=stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.StableDiffusionDepthToImage = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionDepthToImage',
                request_serializer=stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.StableDiffusionInpainting = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionInpainting',
                request_serializer=stable__draw__grpc__pb2.FromImgandMaskandTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.StableDiffusionUpscaler = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionUpscaler',
                request_serializer=stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.StableDiffusionUpscalerXX = channel.unary_unary(
                '/greet.StableDrawGRPC/StableDiffusionUpscalerXX',
                request_serializer=stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.Upscale = channel.unary_unary(
                '/greet.StableDrawGRPC/Upscale',
                request_serializer=stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.DeleteBackground = channel.unary_unary(
                '/greet.StableDrawGRPC/DeleteBackground',
                request_serializer=stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )
        self.GetImageClass = channel.unary_unary(
                '/greet.StableDrawGRPC/GetImageClass',
                request_serializer=stable__draw__grpc__pb2.FromImgOnlyRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.IntReply.FromString,
                )
        self.ImageColorizer = channel.unary_unary(
                '/greet.StableDrawGRPC/ImageColorizer',
                request_serializer=stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
                response_deserializer=stable__draw__grpc__pb2.ImageReply.FromString,
                )


class StableDrawGRPCServicer(object):
    """Missing associated documentation comment in .proto file."""

    def GenCaption(self, request, context):
        """Генерация описания к изображению
        Принимает: byte входного изображения и параметры
        Возвращает: строку описания изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ckpt": "caption_huge_best.pt", #используемые чекпоинты (caption_huge_best.pt или caption_base_best.pt)
        "eval_cider": True,             #оценка с помощью баллов CIDEr
        "eval_bleu": False,             #оценка с помощью баллов BLEU
        "eval_args": "{}",              #аргументы генерации для оценки BLUE или CIDEr, например, "{"beam": 4, "lenpen": 0,6}", в виде строки JSON
        "eval_print_samples": False,    #печатать поколения образцов во время валидации
        "scst": False,                  #Обучение самокритичной последовательности
        "scst_args": "{}",              #аргументы генерации для обучения самокритичной последовательности в виде строки JSON
        "beam": 5,                      #балансировка
        "max_len_a": 0,                 #максимальная длина буфера a
        "max_len_b": 200,               #максимальная длина буфера b
        "min_len": 1,                   #минимальная длина буфера
        "unnormalized": False,          #ненормализовывать
        "lenpen": 1,
        "unkpen": 0,
        "temperature": 1.0,             #температура
        "match_source_len": False,      #сопоставлять с исходной длиной
        "no_repeat_ngram_size": 3,      #не повторять N-граммы размера
        "sampling_topk": 3,             #из скольки тоненов отбирать лучший (0 - не использовать сэмплирование)
        "seed": 7                       #инициализирующее значение для генерации
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionTextToImage(self, request, context):
        """Генерация изображения по описанию
        Принимает: строку описания и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "steps": 50,            #количество шагов выборки
        "samler": "ddim",       #обработчик (доступно "plms", "dpm" и "ddim")
        "ddim_eta": 0.0,        #ddim η (η = 0.0 соответствует детерминированной выборке, работает только на обработчике "ddim")
        "f": 8,                 #коэффициент понижающей дискретизации, чаще всего 8 или 16
        "scale": 9.0,           #безусловная навигационная величина: eps = eps(x, empty) + scale * (eps(x, cond) - eps(x, empty))
        "ckpt": 0,              #выбор контрольной точки модели (0 или 1 для размерностей 512 или 768 соответственно)
        "seed": 42,             #сид (для воспроизводимой генерации изображений)
        "precision": "autocast" #оценивать с этой точностью ("full" или "autocast")
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionImageToImage(self, request, context):
        """Генерация изображения по описанияю и изображению
        Принимает: byte входного изображения и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        'ddim_steps': 50,             #количество шагов выборки ddim
        'ddim_eta': 0.0,              #ddim η (η = 0.0 соответствует детерминированной выборке)
        'f': 8,                       #коэффициент понижающей дискретизации, чаще всего 8 или 16
        'scale': 9.0,                 #безусловная навигационная величина: eps = eps(x, empty) + scale * (eps(x, cond) - eps(x, empty))
        'strength': 0.7,              #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
        'ckpt': 0,                    #выбор весов модели (от 0 до 10)
        'seed': 42,                   #сид (для воспроизводимой генерации изображений)
        'precision': "autocast",      #оценивать с этой точностью ("full" или "autocast")
        "max_dim": pow(512, 2)        # я не могу генерировать на своей видюхе картинки больше 512 на 512
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionDepthToImage(self, request, context):
        """Генерация изображения по описанияю и изображению с применением дополнительного слоя глубины
        Принимает: byte входного изображения, строку описания и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ddim_steps": 50,           #Шаги DDIM, от 0 до 50
        "ddim_eta": 0.0,            #ddim η (η = 0.0 соответствует детерминированной выборке)
        "scale": 9.0,               #от 0.1 до 30.0
        "strength": 0.9,            #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
        "ckpt": 0,                  #выбор весов модели (0)
        "seed": 42,                 #от 0 до 1000000
        "model_type": "dpt_hybrid", #тип модели
        "verbose": True,
        "max_dim": pow(512, 2)      # я не могу генерировать на своей видюхе картинки больше 512 на 512
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionInpainting(self, request, context):
        """Генерация изображения с изменённым фрагментам по изображению, маске и описанию
        Принимает: byte входного изображения, byte изображения маски, строку описания и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ddim_steps": 50,           #Шаги DDIM, от 0 до 50
        "ddim_eta": 0.0,            #ddim η (от 0.0 до 1.0, η = 0.0 соответствует детерминированной выборке)
        "scale": 10.0,              #от 0.1 до 30.0
        "strength": 0.9,            #сила увеличения/уменьшения шума. 1.0 соответствует полному уничтожению информации в инициализирующем образе
        "ckpt": 0,                  #выбор весов модели (0)
        "seed": 42,                 #от 0 до 1000000
        "verbose": False,
        "max_dim": pow(512, 2)      #я не могу генерировать на своей видюхе картинки больше 512 на 512
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionUpscaler(self, request, context):
        """Четырёхкратное увеличение разрешения исходного изображения (апскейл) по изображению и описанию
        Принимает: byte входного изображения, строку описания и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ddim_steps": 50,           #Шаги DDIM, от 2 до 250
        "ddim_eta": 0.0,            #ddim η (от 0.0 до 1.0, η = 0.0 соответствует детерминированной выборке)
        "scale": 9.0,               #от 0.1 до 30.0
        "ckpt": 0,                  #выбор весов модели (0)
        "seed": 0,                  #от 0 до 1000000
        "outscale": 4,              #Величина того, во сколько раз увеличть разшрешение изображения
        "noise_augmentation": 20,   #от 0 до 350
        "verbose": False,
        "max_dim": pow(256, 2)      # я не могу генерировать на своей видюхе картинки больше 256 на 256
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StableDiffusionUpscalerXX(self, request, context):
        """Многократное (2 предпочтительно) увеличение разрешения исходного изображения (апскейл) по изображению и описанию
        Принимает: byte входного изображения, строку описания и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ddim_steps": 20,           #Шаги DDIM, от 2 до 250
        "scale": 0.0,               #от 0.1 до 30.0
        "ckpt": 0,                  #выбор весов модели (0)
        "seed": 0,                  #от 0 до 1000000
        "outscale": 2,              #Величина того, во сколько раз увеличть разшрешение изображения
        "noise_augmentation": 0.0,  #от 0.0 до 1.0
        "negative_prompt": None,    #отрицательное описание (если без него, то None)
        "verbose": False,
        "max_dim": pow(512, 2)      # я не могу генерировать на своей видюхе картинки больше 256 на 256 для x4 и 512 на 512 для x2
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Upscale(self, request, context):
        """Увеличение разрешения исходного изображения (апскейл) по изображению
        Принимает: byte входного изображения и параметры
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "model": 0,                         #Номер модели для обработки (0-5)
        "denoise_strength": 0.5,            #Сила удаления шума. 0 для слабого удаления шума (шум сохраняется), 1 для сильного удаления шума. Используется только для модели 5 (realesr-general-x4v3 model)
        "outscale": 4,                      #Величина того, во сколько раз увеличть разшрешение изображения (модель 3 x2, остальные x4)
        "tile": 0,                          #Размер плитки, 0 для отсутствия плитки во время тестирования
        "tile_pad": 10,                     #Заполнение плитки
        "pre_pad": 0,                       #Предварительный размер заполнения на каждой границе
        "face_enhance": False,              #Использовать GFPGAN улучшения лиц
        "fp32": True,                       #Использовать точность fp32 во время вывода. По умолчанию fp16 (половинная точность)
        "alpha_upsampler": "realesrgan",    #Апсемплер для альфа-каналов. Варианты: realesrgan | bicubic
        "gpu-id": None                      #Устройство gpu для использования (по умолчанию = None) может быть 0, 1, 2 для обработки на нескольких GPU
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeleteBackground(self, request, context):
        """Удаление фона изображения
        Принимает: byte входного изображения
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "model": "DIS", #Доступно "U2NET" или "DIS"
        "RescaleT": 320, #Только для модели U2NET
        #Только для модели "DIM":
        "ckpt": 0,                  # Выбор впретренированных весов модели (0 или 1)
        "interm_sup": False,        # Указать, активировать ли контроль промежуточных функций
        "model_digit": "full",      # Выберите точность с плавающей запятой (устанавливает "half" или "full" точность числа с плавающей запятой)
        "seed": 0,                  # Инициализирующее значение
        "cache_size": [1024, 1024], # Кешированное входное пространственное разрешение, можно настроить на другой размер
        "input_size": [1024, 1024], # Входной пространственный размер модели, обычно используют одно и то же значение params["cache_size"], что означает, что мы больше не изменяем размер изображений
        "crop_size": [1024, 1024]   # Размер случайно обрезки из ввода, обычно он меньше, чем params["cache_size"], например, [920, 920] для увеличения данных
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetImageClass(self, request, context):
        """Получение класса изображения
        Принимает: byte входного изображения
        Возвращает: int класса, где:
        0 - фото с лицом,
        1 - фото без лица,
        2 - профессиональный рисунок,
        3 - непрофессиональный рисунок,
        4 - профессиональный лайн,
        5 - быстрый лайн
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ImageColorizer(self, request, context):
        """Окрашивание чёрно-белого изображения или лайна
        Принимает: byte входного изображения
        Возвращает: int высоты, int ширины сгенерированного изображения и byte самого изображения
        Структура словаря параметров и параметры по-умолчанию:
        params = {
        "ckpt": 0,                         #Выбор модели (от 0 до 3)
        "steps": 1,                        #Количество шагов обработки (минимум 1)
        "compare": False,                  #Сравнивать с оригиналом
        "artistic": True,                  #Дополнительная модель для обработки
        "render_factor": 12,               #Фактор обработки (от 7 до 45) (лучше 12)
        "post_process": True,              #Постобработка
        "clr_saturation_factor": 5,        #Коэффициент увеличения цветовой насыщенности (1 - не добавлять насыщенность)
        "line_color_limit": 50,            #минимальная яркость пикселя, при которой цветовая насыщенность увеличиваться не будет (меньше для цифровых рисунков, больше для рисунков карандашом. 1 если лайн абсолютно чёрный)
        "clr_saturate_every_step": True    #Повышать цветовую насыщенность после каждого шага (играет роль только если количество шагов обработки больше 1)
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_StableDrawGRPCServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GenCaption': grpc.unary_unary_rpc_method_handler(
                    servicer.GenCaption,
                    request_deserializer=stable__draw__grpc__pb2.FromImageRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.TextReply.SerializeToString,
            ),
            'StableDiffusionTextToImage': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionTextToImage,
                    request_deserializer=stable__draw__grpc__pb2.FromTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'StableDiffusionImageToImage': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionImageToImage,
                    request_deserializer=stable__draw__grpc__pb2.FromImageandTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'StableDiffusionDepthToImage': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionDepthToImage,
                    request_deserializer=stable__draw__grpc__pb2.FromImageandTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'StableDiffusionInpainting': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionInpainting,
                    request_deserializer=stable__draw__grpc__pb2.FromImgandMaskandTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'StableDiffusionUpscaler': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionUpscaler,
                    request_deserializer=stable__draw__grpc__pb2.FromImageandTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'StableDiffusionUpscalerXX': grpc.unary_unary_rpc_method_handler(
                    servicer.StableDiffusionUpscalerXX,
                    request_deserializer=stable__draw__grpc__pb2.FromImageandTextRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'Upscale': grpc.unary_unary_rpc_method_handler(
                    servicer.Upscale,
                    request_deserializer=stable__draw__grpc__pb2.FromImageRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'DeleteBackground': grpc.unary_unary_rpc_method_handler(
                    servicer.DeleteBackground,
                    request_deserializer=stable__draw__grpc__pb2.FromImageRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
            'GetImageClass': grpc.unary_unary_rpc_method_handler(
                    servicer.GetImageClass,
                    request_deserializer=stable__draw__grpc__pb2.FromImgOnlyRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.IntReply.SerializeToString,
            ),
            'ImageColorizer': grpc.unary_unary_rpc_method_handler(
                    servicer.ImageColorizer,
                    request_deserializer=stable__draw__grpc__pb2.FromImageRequest.FromString,
                    response_serializer=stable__draw__grpc__pb2.ImageReply.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'greet.StableDrawGRPC', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class StableDrawGRPC(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def GenCaption(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/GenCaption',
            stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
            stable__draw__grpc__pb2.TextReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionTextToImage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionTextToImage',
            stable__draw__grpc__pb2.FromTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionImageToImage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionImageToImage',
            stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionDepthToImage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionDepthToImage',
            stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionInpainting(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionInpainting',
            stable__draw__grpc__pb2.FromImgandMaskandTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionUpscaler(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionUpscaler',
            stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StableDiffusionUpscalerXX(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/StableDiffusionUpscalerXX',
            stable__draw__grpc__pb2.FromImageandTextRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Upscale(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/Upscale',
            stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def DeleteBackground(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/DeleteBackground',
            stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def GetImageClass(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/GetImageClass',
            stable__draw__grpc__pb2.FromImgOnlyRequest.SerializeToString,
            stable__draw__grpc__pb2.IntReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ImageColorizer(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greet.StableDrawGRPC/ImageColorizer',
            stable__draw__grpc__pb2.FromImageRequest.SerializeToString,
            stable__draw__grpc__pb2.ImageReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
